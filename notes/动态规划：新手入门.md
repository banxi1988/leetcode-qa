动态规划：新手入门

## 先来谈谈钱

我们知道现在人民币常用的有如下几种币值的纸币(这里忽略了毛票):

- 一块(1)
- 两块(2)
- 五块(5)
- 十块(10)
- 二十块(20)
- 五十块(50)
- 一百块(100)

显然我们知道有了这几种币值的  纸币我们就可以用来表示 从 1 到 N 块的所有可能的钱的数量。
比如 40 块。我们可以用两张 二十块来表示也可以用 四张十块的来表示。
我们要研究的方向怎么样用最少的纸币表示指定的数额的钱。
我们写这么一个函数用来做这个事情。

```kotlin
/**
 * 计算要表示指定的金额的钱所需要的最少的纸币数
 *  @param money 要表示的钱的金额
 *  @return 返回纸张数的大小
 */
fun c(money :int): int{
}
```

## 先来穷举

比如上面的函数，可能一上来我们并没有一个好的思路，但是没有关系，我们先来在大脑中手动计算一下。
可以得到如下的调用表。

```kotlin
c(1) -> 1 // 一张1块的
c(2) -> 1 // 一张2块的
c(3) -> 2 // 一张2块的 + 一张1块的
c(4) -> 2 // 两张2块的
c(5) -> 1 // 一张5块的
c(6) -> 2 // 一张5块 + 一张1块的
c(7) -> 2 // 一张5块 + 一张2块的
c(8) -> 3 // 一张5块的 + 一张2块的 + 1张一块的
c(9) -> 3 // 一张5块的 + 两张2块的
c(10) -> 1 // 一张10块的
c(11) -> 2 // 一张10块的 + 一张1块的
c(12) -> 2 // 一张10块的 + 一张2块的
c(13) -> 3 // 一张10块的 + 一张2块的 + 一张1块的
c(14) -> 3 // 一张10块的 + 两张2块的
c(15) -> 2 // 一张10块+一张5块
```

手动计算了这么多，我们仿佛已经感受到了一些规律。

```
c(15) = c(10) + c(5)
c(14) = c(10) + c(4)
c(13) = c(10) + c(3)
c(12) = c(10) + c(2)
c(11) = c(10) + c(1)
```

1）先拿出一张小于 `money` 的最大面值的钱。剩下的再递归调用`c`.

一个其实是贪心算法的解法如下：

```go
var rmbBases = [...]int{1, 2, 5, 10, 20, 50, 100}

const rmbBaseCount = len(rmbBases)

// FewestRmbExhcange 返回最小的找零方案
func FewestRmbExhcange(amount int) []int {
	exchanges := []int{}
	remain := amount

	for remain > 0 {
		for i := rmbBaseCount - 1; i > -1; {
			base := rmbBases[i]
			if remain >= base {
				remain = remain - base
				exchanges = append(exchanges, base)
			} else {
				i--
			}
		}
	}
	return exchanges
}
```

## 初级 LIS (longest increasing subsequence)

对于如下数据：

```
5，3，4，8，6，7
```

定义 d(i)为前 i 个数中以 A[i]结尾的最长非降子序列的长度。当我们把 d(1) 到 d(N) 都计算出来答案就这这里的。
（注意：子序列不是子数组，所以不要求连续，所以结果是 3，4，6，7）
显然:

```
前1个数d(1) -> 1(序列:5)
前2个数d(2) -> 1(序列:3; 3 前面没有比3小的)
前3个数d(3) -> 2(序列:3,4; 4 前面有比它小的3, 所以 d(3) = d(2) + 1)
前4个数d(4) -> 3(序列: 3,4,8;8前面比它小的数有3个数，所以 d(4) = max(d(1), d(2), d(3) + 1) = 3)
前5个数d(5) -> 3(序列: 3,4,6: d(5) = d(4)。）
```

此时状态转移方程如下：

```
d(i) = max{1, d(j) + 1} 其中 j <i, A[j] <= A[i]
```

也就是想求出 d(i),就要把 i 前面的各个子序列中，最后一个不大于 A[i]的序列 长度加 1，然后最后求出的最大长度即为 d(i). 当然有可能 i 前面的各个子序列中的最后一个数都大于 A[i],那么 d(i) = 1,即它自身成为一个长度为的子序列。

## 参考

1.  [动态规划：从新手到专家](http://www.hawstein.com/posts/dp-novice-to-advanced.html)
